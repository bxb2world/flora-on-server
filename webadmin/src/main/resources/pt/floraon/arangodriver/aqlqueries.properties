## THIS FILE HAS ALL THE AQL QUERIES USED THROUGHOUT ##
## except minor fragments                            ##
#######################################################

ListDriver.1=\
FOR v IN GRAPH_TRAVERSAL('%1$s', \
	FOR v IN taxent FILTER v.isSpeciesOrInf==true && v.current==true && LENGTH(FOR e IN PART_OF FILTER e._to==v._id RETURN e)==0 RETURN v \
	, 'outbound', {paths:false,filterVertices:[%3$s],vertexFilterMethod:['exclude']}) COLLECT a=v[*].vertex RETURN a
ListDriver.2=FOR v IN %1$s FILTER v.territoryType=='%2$s' RETURN v._id
ListDriver.3=FOR v IN %1$s SORT v.name RETURN v._id
ListDriver.4=FOR v IN %1$s FILTER v.showInChecklist==true SORT v.name RETURN v
ListDriver.5=FOR v IN %1$s FILTER v.territoryType=='%2$s' SORT v.name RETURN v
ListDriver.6=FOR v IN %1$s SORT v.name RETURN v


## This fragment is to be reused in several queries
## it traverses all the territories from the given taxent - given as thistaxon
## These fields must correspond to those in TaxEntAndNativeStatusResult
TraverseTerritoriesFragment=\
thistaxon.rank <= 100 ? [] : (FILTER thistaxon.rank > 100 /* only seek territories for ranks lower than family */ \
FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, INBOUND PART_OF, ANY SYNONYM, BELONGS_TO \
	FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
    RETURN { \
        depth: LENGTH(p.edges) \
        ,existsIn: ns \
        ,territory: v \
        ,vertices: p.vertices[*]._id \
        ,worldDistributionCompleteness: p.vertices[*].worldDistributionCompleteness \
        ,completeDistributionUpstream: (FOR v1 IN 0..100 OUTBOUND v BELONGS_TO FILTER v1._id IN thistaxon.territoriesWithCompleteDistribution RETURN v1._id)[0] \
        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
        ,direction: direction \
    } \
)

## Fetch all taxon leaf nodes and, for each one, the list of territorires and EXISTS_IN relationships.
## TODO: now this traverses the taxonomy downwards, so a species with subspecies does not need to have status assigned.
## however, traversing upwards could also provide useful information...
## Returns an array of TaxEntAndNativeStatusResult class.
ListDriver.7=\
FOR thistaxon IN %2$s %5$s \
	LET npar=LENGTH(FOR v IN 1..1 INBOUND thistaxon PART_OF FILTER v.current==true RETURN v) \
	FILTER thistaxon.isSpeciesOrInf==true %1$s %4$s SORT thistaxon.name %3$s \
	LET wdct = (FOR v IN 0..100 ANY thistaxon SYNONYM \
		FILTER v.worldDistributionCompleteness == 'DISTRIBUTION_COMPLETE' LIMIT 1 \
		RETURN v)[0] \
	RETURN {taxent: MERGE(thistaxon, {leaf: npar==0}) \
		, worldDistributionCompleteness: wdct != NULL \
		, worldDistributionCompletenessTaxEnt: wdct \
		, territories: {@TraverseTerritoriesFragment} \
	}

ListDriver.21=FOR v IN %1$s FILTER v.rank==%2$d SORT v.name RETURN v
ListDriver.22=RETURN {nodes:(FOR v IN %1$s RETURN MERGE(v,{type:PARSE_IDENTIFIER(v._id).collection})), links:[]}

## Fetch taxon info (from TaxEnt name) and the list of territories and EXISTS_IN relationships it has.
## Returns an array of TaxEntAndNativeStatusResult class.
ListDriver.24b=\
FOR thistaxon IN taxent \
	FILTER LOWER(thistaxon.name) == '%1$s' %2$s \
	LET wdct = (FOR v IN 0..100 ANY thistaxon SYNONYM \
		FILTER v.worldDistributionCompleteness == 'DISTRIBUTION_COMPLETE' LIMIT 1 \
		RETURN v)[0] \
	RETURN {taxent: thistaxon \
		, worldDistributionCompleteness: wdct != NULL \
		, worldDistributionCompletenessTaxEnt: wdct \
		, territories: {@TraverseTerritoriesFragment} \
	}

## Same as above but for oldId
ListDriver.24c=\
FOR thistaxon IN taxent \
	FILTER thistaxon.oldId == %1$s \
	LET wdct = (FOR v IN 0..100 ANY thistaxon SYNONYM \
		FILTER v.worldDistributionCompleteness == 'DISTRIBUTION_COMPLETE' LIMIT 1 \
		RETURN v)[0] \
	RETURN {taxent: thistaxon \
		, worldDistributionCompleteness: wdct != NULL \
		, worldDistributionCompletenessTaxEnt: wdct \
		, territories: {@TraverseTerritoriesFragment} \
	}

SpeciesListWrapperDriver.0=\
FOR au IN author FILTER au.idAut==%2$d \
	UPSERT {_from:'%1$s',_to:au._id} \
	INSERT {_from:'%1$s',_to:au._id,main:%3$b} \
	UPDATE {} IN OBSERVED_BY RETURN OLD ? 0 : 1

SpeciesListWrapperDriver.1=\
FOR au IN author FILTER au.idAut==%2$d \
	UPSERT {_from:'%1$s',_to:au._id} \
	INSERT {_from:'%1$s',_to:au._id,main:%3$b} \
	UPDATE {} IN OBSERVED_BY RETURN OLD ? 0 : 1
	
#########################
## TaxEntWrapperDriver ##
#########################

TaxEntWrapperDriver.0=RETURN LENGTH(FOR e IN PART_OF FILTER e._to=='%1$s' RETURN e)
TaxEntWrapperDriver.1=FOR v IN 1..100 ANY '%2$s' %1$s FILTER v._id!='%2$s' RETURN DISTINCT v
TaxEntWrapperDriver.2=FOR v IN 1..1 OUTBOUND '%1$s' PART_OF, HYBRID_OF FILTER v.current RETURN v

## GetEndemismDegree
#TaxEntWrapperDriver.3=\
#FILTER DOCUMENT('%1$s').worldDistributionCompleteness=='DISTRIBUTION_COMPLETE' \
#FOR v,e,p IN 1..100 OUTBOUND '%1$s' EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
#    FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
#    && e.nativeStatus IN [%3$s] \
#    RETURN { \
#        depth: LENGTH(p.edges) \
#        , route: p.edges[0] \
#        , vertices: p.vertices[*].name \
#    } \
#)

#LET all=(FOR v,e IN 1..100 OUTBOUND '%1$s' ANY SYNONYM,EXISTS_IN,PART_OF \
#	FILTER e.nativeStatus IN [%3$s] \
#	RETURN v) \
#FOR v IN all \
#	FOR v1 IN 1..100 INBOUND v BELONGS_TO \

# FOR v,e IN 1..100 OUTBOUND '%1$s' ANY SYNONYM,EXISTS_IN,PART_OF \
#	FILTER e.nativeStatus IN [%3$s] \
#	RETURN v.name
		

## SetObservedIn
TaxEntWrapperDriver.4=UPSERT {_from:'%1$s',_to:'%2$s'} INSERT %3$s UPDATE %3$s IN OBSERVED_IN RETURN OLD ? 0 : 1

## getChildren
TaxEntWrapperDriver.5=\
	FOR v1 IN (FOR v,e,p IN 1..2 INBOUND '%2$s' %1$s,%3$s FILTER (LENGTH(p.edges)==1 && PARSE_IDENTIFIER(p.edges[0]).collection=='PART_OF') \
	|| (LENGTH(p.edges)==2 && PARSE_IDENTIFIER(p.edges[0]).collection=='PART_OF' && PARSE_IDENTIFIER(p.edges[1]).collection=='HYBRID_OF') \
	RETURN DISTINCT v) SORT v1.name RETURN v1
	
## setNativeStatus
## remove the EXISTS_IN link, if it exists
TaxEntWrapperDriver.6=FOR e IN EXISTS_IN FILTER e._from=='%1$s' && e._to=='%2$s' REMOVE e IN EXISTS_IN RETURN OLD ? 0 : 1
## create or update the EXISTS_IN link
TaxEntWrapperDriver.7=UPSERT {_from:'%1$s',_to:'%2$s'} INSERT %3$s UPDATE %3$s IN EXISTS_IN RETURN OLD ? 0 : 1

## getIncludedTaxa
TaxEntWrapperDriver.8=FOR v IN 1..1 INBOUND '%2$s' %1$s FILTER !v.current RETURN v

## For the given TaxEnt, get the list of territories where it exists (and all details associated).
## These fields must correspond to those in TaxEntAndNativeStatusResult
TaxEntWrapperDriver.9=\
FOR thistaxon IN taxent \
	FILTER thistaxon._id == '%1$s' \
	LET wdct = (FOR v IN 0..100 ANY thistaxon SYNONYM \
		FILTER v.worldDistributionCompleteness == 'DISTRIBUTION_COMPLETE' LIMIT 1 \
		RETURN v)[0] \
	RETURN { \
		taxent: thistaxon \
		, worldDistributionCompleteness: wdct != NULL \
		, worldDistributionCompletenessTaxEnt: wdct \
		, territories: thistaxon.rank <= 100 ? [] : (FILTER thistaxon.rank > 100 /* only seek territories for ranks lower than family */ \
		FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, INBOUND PART_OF, ANY SYNONYM, BELONGS_TO \
			FILTER PARSE_IDENTIFIER(v).collection == 'territory' %2$s \
		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus != NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
		    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
		    RETURN { \
		        depth: LENGTH(p.edges) \
		        ,existsIn: ns \
		        ,territory: v \
		        ,vertices: p.vertices[*]._id \
		        ,worldDistributionCompleteness: p.vertices[*].worldDistributionCompleteness \
		        ,completeDistributionUpstream: (FOR v1 IN 0..100 OUTBOUND v BELONGS_TO FILTER v1._id IN thistaxon.territoriesWithCompleteDistribution RETURN v1._id)[0] \
		        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
		        ,direction: direction \
		    } \
	    ) \
	}
## this is the fragment %2$s of the above
TaxEntWrapperDriver.9a=&& v.shortName == '%1$s'

TaxEntWrapperDriver.10=\
LET doc=DOCUMENT('%1$s').territoriesWithCompleteDistribution \
FOR t IN (doc==null ? [] : doc) RETURN DOCUMENT(t)

TaxEntWrapperDriver.11=\
LET doc=DOCUMENT('%1$s') \
LET newarr=PUSH(doc.territoriesWithCompleteDistribution, '%2$s', true) \
LET count=LENGTH(newarr) - LENGTH(doc.territoriesWithCompleteDistribution) \
UPDATE doc WITH {territoriesWithCompleteDistribution: newarr} IN taxent \
RETURN count

TaxEntWrapperDriver.12=\
LET doc=DOCUMENT('%1$s') \
LET newarr=REMOVE_VALUE(doc.territoriesWithCompleteDistribution, '%2$s') \
LET count=LENGTH(doc.territoriesWithCompleteDistribution) - LENGTH(newarr) \
UPDATE doc WITH {territoriesWithCompleteDistribution: newarr} IN taxent \
RETURN count

######################
## NodeWorkerDriver ##
######################

## Detaches the given synonym from the given taxent node, no matter how far it is in the synonym chain.
NodeWorkerDriver.1=\
FOR v,e IN 1..100 ANY '%1$s' SYNONYM \
    FILTER v._id == '%2$s' \
    UPDATE v WITH {current: true} IN taxent \
    REMOVE e IN SYNONYM RETURN OLD

## Get the IDs of all edges connected to the given node
NodeWorkerDriver.2=FOR v,e IN 1 ANY '%1$s' %2$s RETURN e._id

## Get all EXISTS_IN relationships departing from this taxon
NodeWorkerDriver.3=FOR v,e IN 1..100 OUTBOUND '%1$s' EXISTS_IN RETURN {territory: v, existsIn:e}

NodeWorkerDriver.4=FOR v IN attribute FILTER v.name=='%1$s' RETURN v

NodeWorkerDriver.5=FOR v IN territory FILTER v._id=='%1$s' RETURN v

NodeWorkerDriver.6=\
FOR o IN PUSH(UNION( \
	(FOR v IN 1..%3$d ANY '%1$s' %2$s RETURN DISTINCT v._id) \
	, (FOR v,e IN 1..%3$d ANY '%1$s' %2$s RETURN DISTINCT e._id) \
), '%1$s') RETURN o


#RETURN {nodes: \
#	APPEND( [MERGE(DOCUMENT('%1$s'), {type: PARSE_IDENTIFIER('%1$s').collection})] \
#		,(FOR v IN 1..%3$d ANY '%1$s' %2$s RETURN DISTINCT MERGE(v,{type:PARSE_IDENTIFIER(v._id).collection})) \
#		) \
#    ,links:(FOR v,e IN 1..%3$d ANY '%1$s' %2$s RETURN DISTINCT MERGE(e,{type:PARSE_IDENTIFIER(e._id).collection})) \
#}
