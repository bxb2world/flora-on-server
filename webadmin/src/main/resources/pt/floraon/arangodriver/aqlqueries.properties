## THIS FILE HAS ALL THE AQL QUERIES USED THROUGHOUT ##
## except minor fragments                            ##
#######################################################

ListDriver.1=\
FOR v IN GRAPH_TRAVERSAL('%1$s', \
	FOR v IN taxent FILTER v.isSpeciesOrInf==true && v.current==true && LENGTH(FOR e IN PART_OF FILTER e._to==v._id RETURN e)==0 RETURN v \
	, 'outbound', {paths:false,filterVertices:[%3$s],vertexFilterMethod:['exclude']}) COLLECT a=v[*].vertex RETURN a
ListDriver.2=FOR v IN %1$s FILTER v.territoryType=='%2$s' RETURN v._id
ListDriver.3=FOR v IN %1$s SORT v.name RETURN v._id
ListDriver.4=FOR v IN %1$s FILTER v.showInChecklist==true SORT v.name RETURN v
ListDriver.5=FOR v IN %1$s FILTER v.territoryType=='%2$s' SORT v.name RETURN v
ListDriver.6=FOR v IN %1$s SORT v.name RETURN v

## Fetch all taxon leaf nodes and, for each one, the list of territorires and EXISTS_IN relationships.
## TODO: traverse the taxonomy downwards! e.g. a species with subspecies does not need to have status assigned.
ListDriver.7=\
FOR thistaxon IN %2$s %5$s \
	LET npar=LENGTH(FOR v IN 1..1 INBOUND thistaxon PART_OF %6$s RETURN v) \
	FILTER thistaxon.isSpeciesOrInf==true %1$s %4$s SORT thistaxon.name %3$s \
	RETURN {taxent: MERGE(thistaxon, {leaf: npar==0}) \
		, territories: ( \
		FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
			FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
		    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
		    RETURN { \
		        depth: LENGTH(p.edges) \
		        ,existsIn: ns \
		        ,territory: v \
		        ,vertices: p.vertices[*].name \
		        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
		        ,direction: direction \
		    } \
	    ) \
	}

#FOR taxon IN %2$s %5$s \
#	LET npar=LENGTH(FOR v IN 1..1 INBOUND taxon PART_OF %6$s RETURN v) \
#	FILTER taxon.isSpeciesOrInf==true %1$s %4$s SORT taxon.name %3$s \
#	RETURN {taxent: MERGE(taxon, {leaf: npar==0}), territories: UNIQUE( \
#		FOR v,e,p IN 1..100 OUTBOUND taxon EXISTS_IN,PART_OF,ANY SYNONYM,BELONGS_TO \
#		FILTER HAS(v,'showInChecklist')==true		/* ensure last vertex is a territory */ \
#		LET upstr=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1._id).collection=='PART_OF' RETURN e1) \
#		LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0] \
#		LET base=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1).collection=='BELONGS_TO' LIMIT 1 RETURN e1) \
#		RETURN {existsId:ns._id, \
#			nativeStatus: ns.nativeStatus, \
#			occurrenceStatus: ns.occurrenceStatus, \
#			uncertainOccurrence: ns.uncertainOccurrenceStatus, \
#			territory: v.shortName, \
#			territoryName: v.name, \
#			inferred: LENGTH(base)!=0, \
#			uncertain: LENGTH(upstr)!=0, \
#			taxpathlen: LENGTH(upstr) \
#		} \
#	) \
#} 

ListDriver.21=FOR v IN %1$s FILTER v.rank==%2$d SORT v.name RETURN v
ListDriver.22=RETURN {nodes:(FOR v IN %1$s RETURN MERGE(v,{type:PARSE_IDENTIFIER(v._id).collection})), links:[]}

## Fetch taxon info (from TaxEnt key) and the list of territories and EXISTS_IN relationships it has. Similar to ListDriver.7
ListDriver.24a=\
FOR thistaxon IN taxent \
	FILTER thistaxon._id == '%1$s' \
	RETURN {taxent: thistaxon \
		, territories: ( \
		FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
			FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
		    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
		    RETURN { \
		        depth: LENGTH(p.edges) \
		        ,existsIn: ns \
		        ,territory: v \
		        ,vertices: p.vertices[*].name \
		        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
		        ,direction: direction \
		    } \
	    ) \
	}

#FOR thistaxon IN taxent \
#	FILTER thistaxon._id == '%1$s' \
#	RETURN {taxent: thistaxon, endemismDegree: ( \
#		FILTER thistaxon.worldDistributionCompleteness=='DISTRIBUTION_COMPLETE' \
#		FOR v,e IN 1..100 OUTBOUND '%1$s' ANY SYNONYM, EXISTS_IN, PART_OF \
#			FILTER e.nativeStatus IN [%2$s] \
#			RETURN v.name) \
#		, territories: UNIQUE( \
#	    FOR v,e,p IN 1..100 OUTBOUND '%1$s' EXISTS_IN,PART_OF,ANY SYNONYM,BELONGS_TO \
#	    	FILTER v.showInChecklist /* only output territories marked for checklist */ \
#	        LET upstr=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1._id).collection=='PART_OF' RETURN e1)     /* did it climb taxonomic PART_OF? */ \
#	        LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
#	        LET base=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1).collection=='BELONGS_TO' LIMIT 1 RETURN e1)    /* only returns e1 if it climbs up a territory PART_OF */ \
#	        RETURN { \
#	            existsId:ns._id \
#	            ,nativeStatus: ns.nativeStatus \
#	            ,occurrenceStatus: ns.occurrenceStatus \
#	            ,uncertainOccurrence: ns.uncertainOccurrenceStatus \
#	            ,territory: v.shortName \
#	            ,territoryName: v.name \
#	            ,inferred: LENGTH(base)!=0 \
#	            ,uncertain: LENGTH(upstr)!=0, taxpathlen: LENGTH(upstr) \
#	        } \
#	    ) \
#	}

## Same as above, but from TaxEnt name
ListDriver.24b=\
FOR thistaxon IN taxent \
	FILTER LOWER(thistaxon.name) == '%1$s' %2$s \
	RETURN {taxent: thistaxon \
		, territories: ( \
		FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
			FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
		    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
		    RETURN { \
		        depth: LENGTH(p.edges) \
		        ,existsIn: ns \
		        ,territory: v \
		        ,vertices: p.vertices[*].name \
		        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
		        ,direction: direction \
		    } \
	    ) \
	}

#FOR thistaxon IN taxent \
#	FILTER LOWER(thistaxon.name) == '%1$s' %3$s \
#	RETURN {taxent: thistaxon, endemismDegree: ( \
#		FILTER thistaxon.worldDistributionCompleteness=='DISTRIBUTION_COMPLETE' \
#		FOR v,e IN 1..100 OUTBOUND thistaxon ANY SYNONYM, EXISTS_IN, PART_OF \
#			FILTER e.nativeStatus IN [%2$s] \
#			RETURN v.name) \
#		, territories: UNIQUE( \
#	    FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN,PART_OF,ANY SYNONYM,BELONGS_TO \
#	    	FILTER v.showInChecklist \
#	        LET upstr=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1._id).collection=='PART_OF' RETURN e1)     /* did it climb taxonomic PART_OF? */ \
#	        LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
#	        LET base=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1).collection=='BELONGS_TO' LIMIT 1 RETURN e1)    /* only returns e1 if it climbs up a territory PART_OF */ \
#	        RETURN { \
#	            existsId:ns._id \
#	            ,nativeStatus: ns.nativeStatus \
#	            ,occurrenceStatus: ns.occurrenceStatus \
#	            ,uncertainOccurrence: ns.uncertainOccurrenceStatus \
#	            ,territory: v.shortName \
#	            ,territoryName: v.name \
#	            ,inferred: LENGTH(base)!=0 \
#	            ,uncertain: LENGTH(upstr)!=0, taxpathlen: LENGTH(upstr) \
#	        } \
#	    ) \
#	}

## Same as above but for oldId
ListDriver.24c=\
FOR thistaxon IN taxent \
	FILTER thistaxon.oldId == %1$d \
	RETURN {taxent: thistaxon \
		, territories: ( \
		FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
			FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
		    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
		    RETURN { \
		        depth: LENGTH(p.edges) \
		        ,existsIn: ns \
		        ,territory: v \
		        ,vertices: p.vertices[*].name \
		        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
		        ,direction: direction \
		    } \
	    ) \
	}

#FOR thistaxon IN taxent \
#	FILTER thistaxon.oldId == %1$d \
#	RETURN {taxent: thistaxon, endemismDegree: ( \
#		FILTER thistaxon.worldDistributionCompleteness=='DISTRIBUTION_COMPLETE' \
#		FOR v,e IN 1..100 OUTBOUND thistaxon ANY SYNONYM, EXISTS_IN, PART_OF \
#			FILTER e.nativeStatus IN [%2$s] \
#			RETURN v.name) \
#		, territories: UNIQUE( \
#	    FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN,PART_OF,ANY SYNONYM,BELONGS_TO \
#	    	FILTER v.showInChecklist /* only output territories marked for checklist */ \
#	        LET upstr=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1._id).collection=='PART_OF' RETURN e1)     /* did it climb taxonomic PART_OF? */ \
#	        LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
#	        LET base=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1).collection=='BELONGS_TO' LIMIT 1 RETURN e1)    /* only returns e1 if it climbs up a territory PART_OF */ \
#	        RETURN { \
#	            existsId:ns._id \
#	            ,nativeStatus: ns.nativeStatus \
#	            ,occurrenceStatus: ns.occurrenceStatus \
#	            ,uncertainOccurrence: ns.uncertainOccurrenceStatus \
#	            ,territory: v.shortName \
#	            ,territoryName: v.name \
#	            ,inferred: LENGTH(base)!=0 \
#	            ,uncertain: LENGTH(upstr)!=0, taxpathlen: LENGTH(upstr) \
#	        } \
#	    ) \
#	}

SpeciesListWrapperDriver.0=\
FOR au IN author FILTER au.idAut==%2$d \
	UPSERT {_from:'%1$s',_to:au._id} \
	INSERT {_from:'%1$s',_to:au._id,main:%3$b} \
	UPDATE {} IN OBSERVED_BY RETURN OLD ? 0 : 1

SpeciesListWrapperDriver.1=\
FOR au IN author FILTER au.idAut==%2$d \
	UPSERT {_from:'%1$s',_to:au._id} \
	INSERT {_from:'%1$s',_to:au._id,main:%3$b} \
	UPDATE {} IN OBSERVED_BY RETURN OLD ? 0 : 1
	
#########################
## TaxEntWrapperDriver ##
#########################

TaxEntWrapperDriver.0=RETURN LENGTH(FOR e IN PART_OF FILTER e._to=='%1$s' RETURN e)
TaxEntWrapperDriver.1=FOR v IN 1..100 ANY '%2$s' %1$s FILTER v._id!='%2$s' RETURN DISTINCT v
TaxEntWrapperDriver.2=FOR v,e IN 1..1 OUTBOUND '%3$s' %2$s,%4$s FILTER v.current && (HAS(e,'current') && e.current) || !HAS(e,'current') RETURN v

## GetEndemismDegree
## FIXME: Juniperus navicularis
TaxEntWrapperDriver.3=\
FILTER DOCUMENT('%1$s').worldDistributionCompleteness=='DISTRIBUTION_COMPLETE' \
FOR v,e,p IN 1..100 OUTBOUND '%1$s' EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
    FILTER PARSE_IDENTIFIER(v).collection == 'territory' \
    && e.nativeStatus IN [%3$s] \
    RETURN { \
        depth: LENGTH(p.edges) \
        , route: p.edges[0] \
        , vertices: p.vertices[*].name \
    } \
)

#LET all=(FOR v,e IN 1..100 OUTBOUND '%1$s' ANY SYNONYM,EXISTS_IN,PART_OF \
#	FILTER e.nativeStatus IN [%3$s] \
#	RETURN v) \
#FOR v IN all \
#	FOR v1 IN 1..100 INBOUND v BELONGS_TO \

# FOR v,e IN 1..100 OUTBOUND '%1$s' ANY SYNONYM,EXISTS_IN,PART_OF \
#	FILTER e.nativeStatus IN [%3$s] \
#	RETURN v.name
		

## SetObservedIn
TaxEntWrapperDriver.4=UPSERT {_from:'%1$s',_to:'%2$s'} INSERT %3$s UPDATE %3$s IN OBSERVED_IN RETURN OLD ? 0 : 1

## getChildren
TaxEntWrapperDriver.5=\
	FOR v1 IN (FOR v,e,p IN 1..2 INBOUND '%2$s' %1$s,%3$s FILTER (LENGTH(p.edges)==1 && PARSE_IDENTIFIER(p.edges[0]).collection=='PART_OF') \
	|| (LENGTH(p.edges)==2 && PARSE_IDENTIFIER(p.edges[0]).collection=='PART_OF' && PARSE_IDENTIFIER(p.edges[1]).collection=='HYBRID_OF') \
	RETURN DISTINCT v) SORT v1.name RETURN v1
	
## setNativeStatus
## remove the EXISTS_IN link, if it exists
TaxEntWrapperDriver.6=FOR e IN EXISTS_IN FILTER e._from=='%1$s' && e._to=='%2$s' REMOVE e IN EXISTS_IN RETURN OLD ? 0 : 1
## create or update the EXISTS_IN link
TaxEntWrapperDriver.7=UPSERT {_from:'%1$s',_to:'%2$s'} INSERT %3$s UPDATE %3$s IN EXISTS_IN RETURN OLD ? 0 : 1

## getIncludedTaxa
TaxEntWrapperDriver.8=FOR v IN 1..1 INBOUND '%2$s' %1$s FILTER !v.current RETURN v

## For the given TaxEnt, get ths list of territories where it exists (and all details associated).
TaxEntWrapperDriver.9=\
FOR thistaxon IN taxent \
	FILTER thistaxon._id == '%1$s' \
	RETURN {taxent: thistaxon \
		, territories: ( \
		FOR v,e,p IN 1..100 OUTBOUND thistaxon EXISTS_IN, PART_OF, ANY SYNONYM, BELONGS_TO \
			FILTER PARSE_IDENTIFIER(v).collection == 'territory' %2$s %3$s \
		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
		    LET direction = (FOR e1 IN 0..(LENGTH(p.edges)-1) RETURN p.edges[e1]._from==p.vertices[e1]._id ? 'OUTBOUND' : 'INBOUND') \
		    RETURN { \
		        depth: LENGTH(p.edges) \
		        ,existsIn: ns \
		        ,territory: v \
		        ,vertices: p.vertices[*].name \
		        ,edges: p.edges[* RETURN PARSE_IDENTIFIER(CURRENT._id).collection] \
		        ,direction: direction \
		    } \
	    ) \
	}

#FOR thistaxon IN taxent \
#	FILTER thistaxon._id == '%1$s' \
#	RETURN {taxent: thistaxon \
#		, territories: ( \
#		FOR v,e,p IN 1..100 OUTBOUND '%1$s' EXISTS_IN,PART_OF,ANY SYNONYM,BELONGS_TO \
#			FILTER v.showInChecklist \
#		    LET upstr=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1._id).collection=='PART_OF' RETURN e1)     /* did it climb taxonomic PART_OF? */ \
#		    LET ns=(FOR e1 IN p.edges FILTER e1.nativeStatus!=NULL LIMIT 1 RETURN e1)[0]       /* this is the 1st EXISTS_IN edge */ \
#		    LET base=(FOR e1 IN p.edges FILTER PARSE_IDENTIFIER(e1).collection=='BELONGS_TO' LIMIT 1 RETURN e1)    /* only returns e1 if it climbs up a territory PART_OF */ \
#		    RETURN DISTINCT { \
#		        existsId:ns._id \
#		        ,nativeStatus: ns.nativeStatus \
#		        ,occurrenceStatus: ns.occurrenceStatus \
#		        ,uncertainOccurrence: ns.uncertainOccurrenceStatus \
#		        ,territory: v.shortName \
#		        ,territoryName: v.name \
#		        ,inferred: LENGTH(base)!=0 \
#		        ,uncertain: LENGTH(upstr)!=0, taxpathlen: LENGTH(upstr) \
#		    } \
#	    ) \
#	}
